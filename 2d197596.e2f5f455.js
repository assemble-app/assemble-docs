(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{108:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return b}));var r=n(0),a=n.n(r);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var d=a.a.createContext({}),c=function(e){var t=a.a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=c(e.components);return a.a.createElement(d.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},m=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=r,b=u["".concat(o,".").concat(m)]||u[m]||p[m]||i;return n?a.a.createElement(b,l(l({ref:t},d),{},{components:n})):a.a.createElement(b,l({ref:t},d))}));function b(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var d=2;d<i;d++)o[d]=n[d];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},75:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return l})),n.d(t,"toc",(function(){return s})),n.d(t,"default",(function(){return c}));var r=n(3),a=n(7),i=(n(0),n(108)),o={id:"hello_world",title:"Hello world",sidebar_label:"Hello world"},l={unversionedId:"hello_world",id:"hello_world",isDocsHomePage:!1,title:"Hello world",description:"To implement a Live HTML component, you must implement two methods, start and render. When the page first loads, the start method is called 1 time with a HashMap of GET parameters that were in the URL. After you return an instance of your View, the render method will be called to compute the UI. After every event, the render method is called again, so it is important that no expensive computations take place inside the render method. All platform functions are disabled inside during render.",source:"@site/docs/hello_world.md",slug:"/hello_world",permalink:"/docs/hello_world",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/hello_world.md",version:"current",sidebar_label:"Hello world",sidebar:"someSidebar",previous:{title:"Local development",permalink:"/docs/local_development"},next:{title:"DOM events and state",permalink:"/docs/dom_events"}},s=[{value:"Basic Strings with unreset",id:"basic-strings-with-unreset",children:[]},{value:"Using Maud and Tailwind",id:"using-maud-and-tailwind",children:[]}],d={toc:s};function c(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},d,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"To implement a Live HTML component, you must implement two methods, ",Object(i.b)("inlineCode",{parentName:"p"},"start")," and ",Object(i.b)("inlineCode",{parentName:"p"},"render"),". When the page first loads, the ",Object(i.b)("inlineCode",{parentName:"p"},"start")," method is called 1 time with a HashMap of GET parameters that were in the URL. After you return an instance of your View, the ",Object(i.b)("inlineCode",{parentName:"p"},"render")," method will be called to compute the UI. After every event, the render method is called again, so it is important that no expensive computations take place inside the render method. All platform functions are disabled inside during render."),Object(i.b)("h2",{id:"basic-strings-with-unreset"},"Basic Strings with unreset"),Object(i.b)("p",null,"To return HTML for your view, simple return a string from your ",Object(i.b)("inlineCode",{parentName:"p"},"View"),"'s ",Object(i.b)("inlineCode",{parentName:"p"},"render")," method. The CSS styles of the page have been reset so there are no default brower styles. In order to get basic styles use the class ",Object(i.b)("inlineCode",{parentName:"p"},"unreset")),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-rust"}),'extern crate assemble_app;\nextern crate serde;\nuse assemble_app::*;\nuse serde::{Deserialize, Serialize};\nuse std::collections::{HashMap};\n\nassemble_init! {{\n    register_root_view!(ViewHandler);\n}}\n\n\n#[derive(Deserialize, Serialize)]\nstruct ViewHandler {\n}\n\nimpl View for ViewHandler {\n  fn start(_is_connected: bool, _params: HashMap<String, String>) -> Result<Self> {\n    Ok(ViewHandler {})\n  }\n\n  fn render(&self) -> Result<Html> {\n    Ok(r#"<div class="unreset"><h1>Hello world</h1></div>"#.into())\n  }\n}\n')),Object(i.b)("h2",{id:"using-maud-and-tailwind"},"Using Maud and Tailwind"),Object(i.b)("p",null,'Returning strings is not advised. You should properly escape string variables that you interpolate into your template. A more "rusty" approach is to use ',Object(i.b)("inlineCode",{parentName:"p"},"maud")," macro's to build the HTML for you."),Object(i.b)("p",null,"Assemble includes ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"https://tailwindcss.com/"}),"tailwind")," for adding styles to your view. With tailwind you don't need to write CSS and simply style your HTML with classes."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-rust"}),'extern crate assemble_app;\nextern crate serde;\nextern crate maud;\nuse assemble_app::*;\nuse maud::html;\nuse serde::{Deserialize, Serialize};\nuse std::collections::{HashMap};\n\nassemble_init! {{\n    register_root_view!(ViewHandler);\n}}\n\n\n#[derive(Deserialize, Serialize)]\nstruct ViewHandler {\n}\n\nimpl View for ViewHandler {\n  fn start(_is_connected: bool, _params: HashMap<String, String>) -> Result<Self> {\n    Ok(ViewHandler {})\n  }\n\n  fn render(&self) -> Result<Html> {\n    let markup = html! {\n        div class="bg-indigo-700" {\n          div class="max-w-2xl mx-auto text-center py-16 px-8" {\n            h2 class="mt-4 text-3xl font-extrabold text-white" {\n              "Hello world"\n            }\n          }\n\n        }\n    };\n    Ok(markup.into_string())\n  }\n}\n')))}c.isMDXComponent=!0}}]);